!subcode5.f90   output the .f90 file
!Subroutines included in this file:
!            WriteDotF90, WriteNmattp, WriteSpacpf

subroutine WriteDotF90
use paraset1
use paraset2
use paraset3
use paraset4
use paraset5 , only: cmdiff_global
use files
use fido
use ErrControl

integer i,j,k,m ! ,grp
integer lenreal,lenreal2
integer len_num_cm,cm_t
integer, dimension(:), allocatable :: int_ary
!integer max_temp, max_index
!real    sum_temp, maxact_temp


! flag of processing pentran output file
!integer pentran_output
!integer x0,y0,z0,x,y,z,ini,inj,ink
integer cm_i,cm_j,cm_k

appvar=''
prevar=''

!generate pentran input file .f90 
outputfile(5)%fullname='temp_inpred.f90'

cur_filename=outputfile(5)%fullname
open(unit=TEMPF90, file=trim(outputfile(5)%fullname),err=5001)
!open(unit=TEMPF90, STATUS='SCRATCH')
write(TEMPF90, '(A)')  '   PARAMETERS FOR MEMORY ALLOCATION : '
write(TEMPF90, '(A)')  '    maxmem,    maxpcs,    maxgcm,    maxxsg'
write(TEMPF90, '(4I10)')  maxmem, 1, num_cm,group
write(TEMPF90, '(A)')  '    maxcmc,    maxcrs,   maxmmc,   maxmed,   maxfmc,   maxfin'
write(TEMPF90,'(6I10)')   num_cm,maxcrs,maxmmc,maxmed,maxfmc,maxfin 
write(TEMPF90, '(A)')  '    maxgrp,    maxglc,   maxswp,   maxqdm,   maxmat,   maxleg'
write(TEMPF90, '(6I10)')  group, ngroup(2), 8, sn*(sn+2)/8, num_mat, maxleg
write(TEMPF90, '(A)')  '    maxsrc,    maxslc,   maxcmr,   maxlin,   maxarr,   nctlim'
write(TEMPF90,'(6I10)')        num_cm, num_cm, num_cm, 25000, maxmmc+100000,   100000
! write(TEMPF90, '(6I10)')   1,1,num_cm,5000,90000,10000

write(TEMPF90,'(A)') '/-----------------Start Problem Deck---------------'
if(prbname_len .gt. 68) prbname_len=68
write(form, "('(A',I0,',',I0,'X,','A8,1x,I0)' )" ) prbname_len, 68-prbname_len
write(TEMPF90, form)  trim(prbname), 'loglevel', 2 
write(TEMPF90,"('generated by PENMSHXP ' A)")  trim(ver_num)
write(TEMPF90, '(A,I0)') 'Total Number of Fine Meshes:  ', tot_num_fm
write(TEMPF90, '(A,I0)') 'Total Number of Coarse Meshes:  ',num_zlev*zlevel(1)%ncx*zlevel(1)%ncy
write(TEMPF90, '(A,I0)') 'Number of zlevs:  ', num_zlev
write(TEMPF90, '(A,I0)') 'Number of coarse mesh per z lev: ', zlevel(1)%ncx*zlevel(1)%ncy
do j=6,9
 write(TEMPF90, '(I1)') j 
enddo
write(TEMPF90, '(I2)') 10
write(TEMPF90, '(A)') '/'
write(TEMPF90, '(A)') '/-------------BLOCK I (GENERAL PROBLEM info.)-----------'
write(TEMPF90, '(A)') '/'
write(TEMPF90, '(A)') 'ngeom=3d'
write(TEMPF90, '(A)') 'modadj=0'
call intlen(group,lenreal)
write(form, "('(A7,I',I0,',2X,I3)' )") lenreal
write(TEMPF90, form) 'ngroup=', ngroup(1),ngroup(2)

call intlen(sn,lenreal)
write(TEMPF90, "('isn=',i0)") sn

write(TEMPF90, "('nmatl=',i0)") num_mat

write(TEMPF90, "('ixcrs=',i0)") num_cmesh(1)

write(TEMPF90, "('jycrs=',i0)") num_cmesh(2)

write(TEMPF90, "('kzcrs=',i0)") num_cmesh(3)

write(TEMPF90, '(A)') 'lodbal=0'
write(TEMPF90, '(A)') 'timcut=0.'
write(TEMPF90, '(A)') 'tolmgd=-0.200'
write(TEMPF90, '(A)') 'decmpv=0 0 0  T'

write(TEMPF90, '(A)') '/'
write(TEMPF90,'(A)') '/------------------BLOCK II(geometry)------------------'
!fine mesh # in any direction(x,y,z) must be less than 9999
!or change temp_bit
allocate(int_ary(num_cmesh(1)) )
 
do m=1, 3
 write(TEMPF90,'(A)')  '/'
 write(TEMPF90, '(A,A,A)') '/ ',cgdim(m)%var1,' coarse-mesh position'
 write(TEMPF90, '(A)') '/'

 write(TEMPF90,'(A,6(ES11.4 ,1X) )')  cgdim(m)%var2,cgdim(m)%boundary

! fine mesh distribution along x
 do k=1, num_cmesh(3)
  write(TEMPF90,'(A)')  '/'
  write(TEMPF90,'(A,A,A,I3)') '/ ', cgdim(m)%var1,' fine mesh distribution for zlev=',k
  write(TEMPF90,'(A)')  '/'
  do j=1,num_cmesh(2)
   do i=1, num_cmesh(1)
    int_ary(i)=zlevel(k)%cm_zlev(i,j)%fine(m)
   enddo
  
!    call intlen(zlevel(k)%cm_zlev(1,j)%fine(m),lenreal)
 if(k .eq. 1 .and. j .eq. 1) then
!     write(form,"('(A,I',I0,',1X,',I0,'(I0,1X))' )") lenreal,(79-lenreal-cgdim(m)%int3)/(lenreal+1)  
!     write(TEMPF90,form) &
!       cgdim(m)%var3,(zlevel(k)%cm_zlev(i,j)%fine(m),i=1,num_cmesh(1)) 
     call FidoIntArray(int_ary,num_cmesh(1),0,0)
     prevar=cgdim(m)%var3
     appvar=''
     call fidowriting(TEMPF90,0)
    else
     call FidoIntArray(int_ary,num_cmesh(1),0,0)
     prevar=''
     appvar=''
     call fidowriting(TEMPF90,cgdim(m)%int3)
!  write(form,"('(',I0,'X,',I0,'(I0,1X))' )") cgdim(m)%int3,(79-lenreal-cgdim(m)%int3)/(lenreal+1)   
!     write(TEMPF90,form) &
!       (zlevel(k)%cm_zlev(i,j)%fine(m),i=1,num_cmesh(1)) 
    endif
  enddo
 enddo 
! medium mesh distribution along x
 do k=1, num_cmesh(3)
  write(TEMPF90,'(A)')  '/'
  write(TEMPF90,'(A,A,A,I3)') '/ ', cgdim(m)%var1,' medium mesh distribution for zlev=',k
  write(TEMPF90,'(A)')  '/'
  do j=1,num_cmesh(2)
   do i=1, num_cmesh(1)
    int_ary(i)=zlevel(k)%cm_zlev(i,j)%med(m)
   enddo
!    call intlen(zlevel(k)%cm_zlev(1,j)%med(m),lenreal)
    if(k .eq. 1 .and. j .eq. 1) then
     call FidoIntArray(int_ary,num_cmesh(1),0,0)
     prevar=cgdim(m)%var4
     appvar=''
     call fidowriting(TEMPF90,0)
!     write(form,"('(A,I',I0,',1X,',I0,'(I0,1X))' )")  lenreal,(79-lenreal-cgdim(m)%int4)/(lenreal+1)
!     write(TEMPF90,form) &
!       cgdim(m)%var4,(zlevel(k)%cm_zlev(i,j)%med(m),i=1,num_cmesh(1)) 
    else
     call FidoIntArray(int_ary,num_cmesh(1),0,0)
     prevar=''
     appvar=''
     call fidowriting(TEMPF90,cgdim(m)%int4)
!      write(form,"('(',I0,'X,',I0,'(I0,1x))' )") cgdim(m)%int4, (79-lenreal-cgdim(m)%int4)/(lenreal+1)
!      write(TEMPF90,form) &
!       (zlevel(k)%cm_zlev(i,j)%med(m),i=1,num_cmesh(1)) 
    endif
  enddo
 enddo 

enddo !m

deallocate(int_ary)

write(TEMPF90,'(A)')  '/'
do k=1, num_cmesh(3)
 write(TEMPF90,'(A, I3)')  '/  material distribution for zlev=', k
 write(TEMPF90,'(A)')  '/'
 do j=1, num_cmesh(2)
   do i=1, num_cmesh(1)
    cm_t=(k-1)*num_cm_zlev+(j-1)*num_cmesh(1)+i
    write(TEMPF90,"('    nmattp=',I0)") cm_t
    call WriteNmattp(i,j,k,TEMPF90)
   enddo
 enddo
enddo


call intlen(num_cm, len_num_cm)

call FidoRealArray(flxini,num_cm,3,0,1)
prevar='flxini='
appvar=''
call fidowriting(TEMPF90,0)

call FidoIntArray(mathmg,num_cm,0,1)
prevar='mathmg='
appvar='   T'
call fidowriting(TEMPF90,0)


write(TEMPF90, '(A)') '/'              
write(TEMPF90, '(A)') '/ ------------- BLOCK III (CROSS SECTIONS) -----------'
write(TEMPF90, '(A)') '/'  
 write(form,"('(A9,A',I0,')' )") len_trim(prb_xs%fullname)
write(TEMPF90, form ) 'lib=file:', prb_xs%fullname
!write(TEMPF90,'(A)') prb_xs%fullname
write(TEMPF90, '(A7,I1,2X,A7,I1)') 'legord=', legord , 'legoxs=', legoxs
write(TEMPF90, '(A6,I1)') 'nxtyp=',nxtyp
call intlen(ihm,lenreal)
write(TEMPF90, '(A4,I0)')  'ihm=',ihm 
call intlen(iht,lenreal)
call intlen(ihs, lenreal2)
write(TEMPF90, '(A4,I0,2X,A4,I0)') 'iht=',iht, 'ihs=',ihs
call intlen(ihng, lenreal)
write(TEMPF90,'(A5,I0)')  'ihng=',ihng 
call FidoRealArray(chig,num_mat*group,-4,-group,1)
prevar='chig='
appvar=''
call fidowriting(TEMPF90,0)
prevar=''
write(TEMPF90, '(A7,I0,4X,A)')  'nxcmnt=',num_comment, 'T'


write(TEMPF90, '(A)') '/'
write(TEMPF90, '(A)') '/------------- BLOCK IV (CONTROL OPTIONS) --------------'
write(TEMPF90, '(A)' ) '/'
write(TEMPF90, "('ncoupl=',I1)") ncoupl
call intlen(nprtyp,lenreal)
write(TEMPF90, "('nprtyp=',I0)") nprtyp
write(TEMPF90, "('nrdblk=',I1)") nrdblk

!call  FidoRealArray(tolin, tolin_len,-2,0,1)
call  FidoRealArray(tolin, 1,-2,0,1)
prevar='tolin='
appvar=''
call fidowriting(TEMPF90,0)

call  FidoRealArray(tolout, 1,-2,0,1)
prevar='tolout='
appvar=''
call fidowriting(TEMPF90,0)


write(TEMPF90, "('dtwmxw=',f4.2)") dtwmxw
call intlen(maxitr(1),lenreal)
write(TEMPF90, "('maxitr=',I0,3X,I3)") maxitr(1), maxitr(2)
write(TEMPF90, "('methit=', I1)") methit

if(sec_flag(2) .eq. 0) then
do k=1, num_cmesh(3)
  do j=1, num_cmesh(2)
    do i=1, num_cmesh(1)
     if(cmdiff_global .ne. 0) then
           zlevel(k)%cm_zlev(i,j)%ndmeth=cmdiff_global
     else
           zlevel(k)%cm_zlev(i,j)%ndmeth=ndmeth_global
      endif
    enddo
  enddo
enddo

endif

do k=1, num_cmesh(3)
  write(TEMPF90,'(A)')  '/'
  write(TEMPF90,'(A,I3)') &
  '/  Starting or selected differencing scheme,for each coarse-mesh, for z-level= ', k
  write(TEMPF90,'(A)')  '/'
  do j=1,num_cmesh(2)
    call intlen(zlevel(k)%cm_zlev(1,j)%ndmeth,lenreal)
 if(k .eq. 1 .and. j .eq. 1) then
 write(form,"('(A7,I',I0,',1X,',I0,'(I0,1X))' )") lenreal,(70-lenreal)/(lenreal+1)
      write(TEMPF90,form) &
       'ndmeth=',(zlevel(k)%cm_zlev(i,j)%ndmeth,i=1,num_cmesh(1)) 
    else
      write(form,"('(7X,',I0,'(I0,1X))' )") 70/(lenreal+1)
      write(TEMPF90,form ) &
       (zlevel(k)%cm_zlev(i,j)%ndmeth,i=1,num_cmesh(1)) 
    endif
  enddo
enddo 


write(TEMPF90,"('nzonrb=',I0,2X,f5.3,I3)") number_of_zones, damping_fact, skip_iter
write(TEMPF90,"('methac=',I1, 5X, ' T')") methac


write(TEMPF90,'(A)') '/------------------BLOCK V(source)------------------'
write(TEMPF90,'(A)')  '/'
! write(*,*) num_source
if(s_format .ne. 2) then
call FidoIntArray(nsdef,num_source,10,1)
prevar='nsdef='
appvar=''
call fidowriting(TEMPF90,0)
 

call FidoIntArray(nscmsh,num_source,10,1)
prevar='nscmsh='
appvar=''
call fidowriting(TEMPF90,0)


call FidoRealArray(sref,3*num_source,3,3,1)
prevar='sref='
appvar=''
call fidowriting(TEMPF90,0)

call FidoRealArray(serg,group*num_source,-3,group,1)
prevar='serg='
appvar=''
call fidowriting(TEMPF90,0)

call FidoRealArray(smag,num_source,-5,0,1)
prevar='smag='
appvar=''
call fidowriting(TEMPF90,0)

else

call FidoRealArray(rkdef,1,3,0,1)
prevar='rkdef='
appvar='    T'
call fidowriting(TEMPF90,0)

endif

input_len_sp=0
fido_char_sp=0

do i=1, num_source
  call intlen(i, lenreal)
  call TransCmIndex(nscmsh(i), cm_i, cm_j, cm_k)
  if(i .eq. 1) then
   write(TEMPF90,"('spacpf=', I0,2X, I3,2X,I10)") i,-1,&
        zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)&
             *zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3)  
  else

   write(TEMPF90,"(7x, I0,2X, I3,2X,I10)") i,-1,&
        zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)&
             *zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3)  
  endif 
  call WriteSpacpf(cm_i,cm_j,cm_k,TEMPF90,i,0)
  fido_char_sp=fido_char_sp+num_fido_char
enddo

if(input_len_sp .gt. max_input_len) max_input_len=input_len_sp
if(fido_char_sp .gt. max_fido_char) max_fido_char=fido_char_sp

write(TEMPF90,'(A)') '/'
write(TEMPF90,'(A)') '/------------- BLOCK VI (BOUNDARY CONDITIONS) ---------'
write(TEMPF90,'(A)') '/'
write(TEMPF90,'(A)') '/ var   type  Group albedos'
do i=1, 6
 if (bcs(i) .eq. 1) then
  call FidoRealArray(albedo(i)%albedo_grp,group,0,0,1)
  write(prevar,"(A7,I1,'    ')") bc_char(i),bcs(i)
  appvar=''
  if(i .eq. 6) appvar='       T'
  call fidowriting(TEMPF90,3) 
 else
   if(i .eq. 6) then
     write(TEMPF90,"(A7,I1,'    ',A1)") bc_char(i),bcs(i), 'T'
   else
     write(TEMPF90,"(A7,I1,'    ')") bc_char(i),bcs(i) 
   endif
 endif
enddo
write(TEMPF90,'(A)') '/'
write(TEMPF90,'(A)') '/------------- BLOCK VII (PRINTING CONDITIONS) ---------'
write(TEMPF90,'(A)') '/'
write(TEMPF90,'(A)') '/'
write(TEMPF90,'(A)') 'nxspr=0 nmatpr=1 ngeopr=1 nsrcpr=0 nsumpr=1'
if(num_cm .gt. 2) then
write(TEMPF90,'("meshpr=" ,I0,"I-1",1x,I0)') num_cm-2,-num_cm
else if (num_cm .eq. 1) then
write(TEMPF90,'("meshpr=-1" )') 
else
write(TEMPF90,'("meshpr=-1 -1")') 
endif
write(TEMPF90,'(A)') 'nfdump=1 nsdump=0 njdump=0'
write(TEMPF90,"('nadump=',I1,'     ',A1)") 0, 'T'
!write(TEMPF90,'(A)')  '/front'
!call intlen(front(1),lenreal)
!write(TEMPF90,"('nadump=',I0,<4-lenreal>x,I2,<num_cmesh(1)-1>(I3,1x,I2,1x))") front(1),3,&
!                                          (front(i), 3, i=2,num_cmesh(1))
!do i=2,num_cmesh(3)
!  write(TEMPF90,'(7X, <num_cmesh(1)>(I3,1x,I2,1x))') (front((i-1)*num_cmesh(1)+j),3,j=1,num_cmesh(1))  
!enddo
!write(TEMPF90,'(A)')  '/back'  

!do i=1,num_cmesh(3)
!  write(TEMPF90,'(7X, <num_cmesh(1)>(I3,1x,I2,1x))') (back((i-1)*num_cmesh(1)+j),4,j=1,num_cmesh(1))  
!enddo
!write(TEMPF90, '(A)') '/left'
!do i=1,num_cmesh(3)
!  write(TEMPF90,'(7X, <num_cmesh(2)>(I3,1x,I2,1x))') (left((i-1)*num_cmesh(2)+j),1,j=1,num_cmesh(2))  
!enddo
!write(TEMPF90, '(A)') '/right'
!do i=1,num_cmesh(3)
!  if (i .lt. num_cmesh(3)) then
!   write(TEMPF90,'(7X, <num_cmesh(2)>(I3,1x,I2,1x))') (right((i-1)*num_cmesh(2)+j),2,j=1,num_cmesh(2))  
!  else
!   write(TEMPF90,"(7X, <num_cmesh(2)>(I3,1x,I2,1x),4X,'T')") (right((i-1)*num_cmesh(2)+j),2,j=1,num_cmesh(2))
!  endif
!enddo        

!deallocate(front, back, left, right)                                                     
close(TEMPF90)                                                            

call RefineDotF90

!do i=1, 3
! deallocate(cgdim(i)%boundary)
!enddo


5000 return

5001  write(err_message,*) 'open file error: can not creat temp file '
      call TrapOpenError(1)

5099 end subroutine


! write varible nmattp
subroutine WriteNmattp(cm_i,cm_j,cm_k,filehandler)
use files
use fido
use paraset2
use paraset3
use paraset4

integer cm_i,cm_j,cm_k, filehandler

integer i,j,k,m, m_in
integer fm_num_tot, fm_num_zfine
integer,dimension(:), allocatable :: int_array

fm_num_tot=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)*&
           zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)
fm_num_zfine=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)

select case (zlevel(cm_k)%cm_zlev(cm_i,cm_j)%uni_zfine)

case(0)
  allocate(oneline1(0))    
   output_len=0
   write(prevar,"(I0,'R',I0)") fm_num_tot,zlevel(cm_k)%cm_zlev(cm_i,cm_j)%mat_matrix(1,1,1)
   appvar=''
case(1)
  allocate(int_array(fm_num_zfine))    
  do m=1, fm_num_zfine
   i=mod(m-1,zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
   j=int((m-1)/zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
   int_array(m)=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%mat_matrix(i,j,1)
  enddo
!  !call FidoIntArray(zlevel(cm_k)%cm_zlev(cm_i,cm_j)%mat_matrix,fm_num_tot,-fm_num_zfine)
  call FidoIntArray(int_array,fm_num_zfine,-zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1),1)
  deallocate(int_array)
  prevar=''
  if(zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3) .gt. 1) then
   write(appvar,"(I0,'Q',I0)") zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3)-1,fm_num_zfine
  else
   appvar=''
  endif
case default
  
  allocate(int_array(fm_num_tot))
  
  do m=1, fm_num_tot
   k=int((m-1)/fm_num_zfine)+1
   m_in=m-(k-1)*fm_num_zfine
   i=mod(m_in-1,zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
   j=int((m_in-1)/zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
   int_array(m)=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%mat_matrix(i,j,k)
  enddo
  !call FidoIntArray(zlevel(cm_k)%cm_zlev(cm_i,cm_j)%mat_matrix,fm_num_tot,-fm_num_zfine)
  call FidoIntArray(int_array,fm_num_tot,-fm_num_zfine,1)
  deallocate(int_array)
  prevar=''
  appvar=''
end select


call fidowriting(filehandler,0)
end subroutine

! write varible spacpf
subroutine WriteSpacpf(cm_i,cm_j,cm_k,filehandler,src_num, w_flag)
use files
use fido
use paraset1
use paraset2
use paraset3
use paraset4


!w_flag: src weight (grp num for venus), default w_flag=0
integer cm_i,cm_j,cm_k, filehandler,src_num,w_flag

integer i,j,k,m, m_in
integer fm_num_tot, fm_num_zfine
integer ncm
real,dimension(:), allocatable :: float_array

fm_num_tot=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(3)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)*&
           zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)
fm_num_zfine=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1)*zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(2)
allocate(float_array(fm_num_tot))

do m=1, fm_num_tot
  k=int((m-1)/fm_num_zfine)+1
  m_in=m-(k-1)*fm_num_zfine
  i=mod(m_in-1,zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
  j=int((m_in-1)/zlevel(cm_k)%cm_zlev(cm_i,cm_j)%fine(1))+1
  float_array(m)=zlevel(cm_k)%cm_zlev(cm_i,cm_j)%src_matrix(i,j,k)/&
       zlevel(cm_k)%cm_zlev(cm_i,cm_j)%sum_act
enddo

 
if(IsFidoSrc .eq. 1) then
call FidoRealArray(float_array,fm_num_tot,DotBit,-fm_num_zfine,1)
input_len_sp=input_len_sp+fm_num_tot+5
deallocate(float_array)
prevar=''
appvar=''
ncm=(cm_k-1)*num_cm_zlev+(cm_j-1)*num_cmesh(1)+cm_i
if(ncm .eq. nscmsh(num_source) .and. w_flag .eq. 0) appvar='  T'
call fidowriting(filehandler,0)
else
 write(filehandler, "(5(ES12.5,1x) )") float_array
 if(src_num .eq. num_source) then 
 m=mod(fm_num_tot, 5)
 if(m .ne. 0) then
  i=fm_num_tot-m
 else
  m=5
  i=fm_num_tot-5
 endif
 backspace(filehandler)
 if(w_flag .eq. 0) then
   write(form, "( '(', I0,'(ES12.5,1x), 2x, A1',')'   )" ) m
   write(filehandler, fmt=form ) float_array(i+1:fm_num_tot), 'T'
 else
   write(filehandler, "(5(ES12.5,1x) )") float_array(i+1:fm_num_tot)
 endif
 endif
endif !IsFidoSrc



return
end subroutine


!recount the total number of lines of prbname.f90 file
subroutine RefineDotF90
use files
use fido
use ErrControl
use paraset2
use paraset4
use paraset3

integer name_len,dir_len,ext_len, fullname_len
integer i
integer Iseof
character*100 line
write(form,"('(A',I0,',A4)' )") prbname_len
write(outputfile(4)%name,form) prbname,'_out' 
outputfile(4)%ext='pen'

name_len=len_trim(outputfile(4)%name)
dir_len=len_trim(outputfile(4)%dir)
ext_len=len_trim(outputfile(4)%ext)

fullname_len=name_len+1+ext_len
do i=1,fullname_len
  if(i .le. name_len) then
    outputfile(4)%fullname(i:i)=outputfile(4)%name(i:i)
   else if(i .eq. name_len+1) then
    outputfile(4)%fullname(i:i)='.'
   else if(i .ge. name_len+2 .and. i .le. fullname_len) then
    outputfile(4)%fullname(i:i)=outputfile(4)%ext(i-name_len-1:i-name_len-1)
  endif
enddo 

open(unit=TEMPF90, file=trim(outputfile(5)%fullname),STATUS='OLD',err=5401)
Iseof=0
do while(Iseof .eq. 0) 
 read(TEMPF90,*,iostat=Iseof)
 maxlin=maxlin+1
enddo
close(TEMPF90)
maxlin=maxlin-1
maxarr=max_input_len
if(maxarr .lt. max_fm*num_group*num_source) & 
 maxarr=max_fm*num_group*num_source

if( maxarr .lt. num_group*num_material*ihm*(legoxs+1) ) &
maxarr=num_group*num_material*ihm*(legoxs+1)

maxarr=maxarr+50


nctlim=max_fido_char+50


open(unit=TEMPF90, file=trim(outputfile(5)%fullname),STATUS='OLD',err=5401)
open(unit=OUTF90, file=trim(outputfile(4)%fullname),err=5402)
Iseof=0

do i=1,maxlin
  read(TEMPF90,'(A)',iostat=Iseof) line
  if(Iseof .ne. 0) then
   cur_filename=outputfile(5)%fullname
   write(err_message,*) 'fail to copy temp_inpred.f90 to prbnam.f90'
   call TrapReadError(1)
   return
  endif
  if(i .eq. 9) then
   write(OUTF90,'(6I10)')  num_source, num_source, num_cm, maxlin+50, maxarr,  nctlim
  else
   write(OUTF90,'(A)') trim(line)
  endif
enddo

close(unit=TEMPF90,status='DELETE')
close(OUTF90)
   
5400 return
5401 cur_filename=outputfile(5)%fullname
     write(err_message,*) 'open temp_inpred.f90 file error'
     call TrapOpenError(1)
5402 cur_filename=outputfile(4)%fullname
     write(err_message,*) 'can not creat output file prbname.f90 file error.'
     call TrapOpenError(1)
5499 end subroutine


subroutine WriteTitanInp
use paraset1
use paraset2
use paraset3
use paraset4
use paraset5
use files
use fido
use ErrControl

integer i,j,k
integer cm_i, cm_j, cm_k
integer q,cm_t, solver_id

integer, dimension(:), allocatable :: int_ary
real, dimension(:), allocatable :: rea_ary
character, dimension(:), allocatable :: oneline2, oneline3

cur_filename=trim(prbname)//'_titan.inp'
cur_fileunit=54
outputfile(6)%fullname=trim(cur_filename)

open(unit=cur_fileunit, file=trim(cur_filename), err=5401)

write(cur_fileunit, "('/* TITAN input file ',A)") trim(cur_filename)
write(cur_fileunit, "('/* generated by PENMSHXP ' A)")  trim(ver_num)
write(cur_fileunit, "('/* total number of fine meshes: ', I0)") tot_num_fm
write(cur_fileunit, "('/* total number of coarse meshes: ', I0)") num_zlev*zlevel(1)%ncx*zlevel(1)%ncy

write(cur_fileunit, "('/* Number of zlevs: ', I0)")  num_zlev
write(cur_fileunit, "('/* Number of coarse mesh per z lev: ',I0)")  zlevel(1)%ncx*zlevel(1)%ncy
write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#0  /general transport parameter quadrature')") 
write(cur_fileunit, "('/acceptable keywords: nquad, tquad, oquad, splitq(multi), ncmesh, numsrc, nummat, numgrp ')")
write(cur_fileunit, "('/ nquad: number of quadratures.')")
write(cur_fileunit, "('/ tquad: type of quadratures, NumOfEntry=nquad (0=LevelSym, 1=LegendreCheby) ')")
write(cur_fileunit, "('/ oquad: order of quadratures, NumOfEntry=nquad (even number) ')")
write(cur_fileunit, "('/ splitq: ordinate splitting setup ')")
write(cur_fileunit, "('/   splitq=QuadId, #Splitting, SplitDirIDs, SplitOrders, SplitType, Topnums, alpha ')")
write(cur_fileunit, "('/   QuadId=1, 2,..or nquad, #Splitting=num of splitting directions ')")
write(cur_fileunit, "('/   #Splitting= total num of splitting directions in QuadID ')")
write(cur_fileunit, "('/   SplitDirIDs=splitting direction IDs in the base quadrature,NumOfEntry=#Splitting ')")
write(cur_fileunit, "('/   SplitOrder=splitting order for each splitting direction,NumOfEntry=#Splitting ')")
write(cur_fileunit, "('/   SplitType: 0=rectangular, 1=Pn-Tn, 2=circular, NumOfEntry=#Splitting ')")
write(cur_fileunit, "('/   Topnum: rectangular: unused; Pn-Tn: Num of dirs on top level; circular: # of circles. NumOfEntry=#Splitting ')")
write(cur_fileunit, "('/   alpha: rectangular/Pn-Tn: unused (angular range for future version); circular: derail angle. NumOfEntry=#Splitting ')")
write(cur_fileunit, "('/ ncmesh: # of coarse mesh along x, y ,z . NumOfEntry=3 ')")
write(cur_fileunit, "('/ numsrc: # of sources . NumOfEntry=1 ')")
write(cur_fileunit, "('/ nummat: # of materials . NumOfEntry=1 ')")
write(cur_fileunit, "('/ numgrp: # of groups . NumOfEntry=1 ')")

write(cur_fileunit, "('ncmesh=',3(I0,2x))") num_cmesh
write(cur_fileunit, "('numsrc=',I0)") nprtyp
write(cur_fileunit, "('nummat=',I0)") num_material
write(cur_fileunit, "('numgrp=',I0)") num_group

write(cur_fileunit, "('nquad=', I0)") num_quad
allocate(int_ary(num_quad))
!quad type
do q=1, num_quad
  int_ary(q)=quad(q)%tquad
enddo
call FidoIntArray(int_ary,num_quad,0,0)
prevar='tquad='
appvar=''
call fidowriting(cur_fileunit,0)
!quad order
do q=1, num_quad
  int_ary(q)=quad(q)%oquad
enddo
call FidoIntArray(int_ary,num_quad,0,0)
prevar='oquad='
appvar=''
call fidowriting(cur_fileunit,0)


do q=1, num_quad
  if (quad(q)%num_split .gt. 0) then
    if (allocated(int_ary) ) deallocate(int_ary)
    allocate(int_ary(2+quad(q)%num_split*4))
    int_ary(1)=q
    int_ary(2)=quad(q)%num_split

    do i=1, quad(q)%num_split
      int_ary(i+2)=quad(q)%direc_split(i)%spid
    enddo
    do i=1, quad(q)%num_split
      int_ary(i+2+quad(q)%num_split)=quad(q)%direc_split(i)%order
    enddo
    do i=1, quad(q)%num_split
      int_ary(i+2+2*quad(q)%num_split)=quad(q)%direc_split(i)%spt_id
    enddo
    do i=1, quad(q)%num_split
      int_ary(i+2+3*quad(q)%num_split)=quad(q)%direc_split(i)%topnum
    enddo
    call FidoIntArray(int_ary,2+4*quad(q)%num_split,0,0)
    
 if(allocated(oneline2)) deallocate(oneline2)
 allocate(oneline2(output_len))
 oneline2(1:output_len)=oneline1(1:output_len)
    k=output_len
 if(allocated(rea_ary)) deallocate(rea_ary)
 allocate(rea_ary(quad(q)%num_split))
 do i=1, quad(q)%num_split
   rea_ary(i)=quad(q)%direc_split(i)%alpha
 enddo
 call FidoRealArray(rea_ary,quad(q)%num_split,-5,0,1)
    if(allocated(oneline3)) deallocate(oneline3)
 j=k+1+output_len
 allocate(oneline3(j))
 oneline3(1:k)=oneline2(1:k)
 oneline3(k+1:k+1)=' '
 oneline3(K+2:j)=oneline1(1:output_len)
 deallocate(oneline1)
 output_len=j
 allocate(oneline1(output_len))
 oneline1(1:output_len)=oneline3(1:output_len)
 deallocate(oneline2, oneline3)
 prevar='splitq='
    appvar=''
    call fidowriting(cur_fileunit,0)
  
  endif
enddo

write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#1  /Section 1 : Geometry setup')") 
write(cur_fileunit, "('/acceptable keywords: dcpara, xcmbnd, ycmbnd, zcmbnd, cmxfin, cmyfin, cmzfin, cmsolv,cmdiff,cmquad ')")
write(cur_fileunit, "('/ dcpara: spatial parallel factor along x, y, z (future version)')")
write(cur_fileunit, "('/ xcmbnd, ycmbnd, zcmbnd: x,y,z coarse mesh boundaries, NumOfEntry=ncmesh+1 ')")
write(cur_fileunit, "('/ cmxfin, cmyfin, cmzfin: fine mesh number along x,y,z for each coarse mesh, NumOfEntry=TotNumOfCM ')")
write(cur_fileunit, "('/ cmsolv: solver ID for each corase mesh, 0=Sn, 1=Characteristics ')")
write(cur_fileunit, "('/ cmdiff: Differencing Scheme ID for each corase mesh, 1=DD with fixup, 2=DTW ')")
write(cur_fileunit, "('/ cmquad: Quadrature ID for each coarse mesh, available values=1,2,... or nquad ')")

write(cur_fileunit, "('dcpara=1,1,1')") 
write(cur_fileunit,"('xcmbnd=', 6(ES12.5 ,1X) )")  cgdim(1)%boundary
write(cur_fileunit,"('ycmbnd=', 6(ES12.5 ,1X) )")  cgdim(2)%boundary
write(cur_fileunit,"('zcmbnd=', 6(ES12.5 ,1X) )")  cgdim(3)%boundary

 if(allocated(int_ary)) deallocate(int_ary)
 allocate(int_ary(num_cm))
! fine mesh distribution along x
 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       int_ary(q)=zlevel(k)%cm_zlev(i,j)%fine(1)
     enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmxfin='
 appvar=''
 call fidowriting(cur_fileunit,0)

 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       int_ary(q)=zlevel(k)%cm_zlev(i,j)%fine(2)
     enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmyfin='
 appvar=''
 call fidowriting(cur_fileunit,0)

 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       int_ary(q)=zlevel(k)%cm_zlev(i,j)%fine(3)
     enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmzfin='
 appvar=''
 call fidowriting(cur_fileunit,0)

 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       int_ary(q)=zlevel(k)%cm_zlev(i,j)%solver_id
     enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmsolv='
 appvar=''
 call fidowriting(cur_fileunit,0)
 
 if(cmdiff_global .eq. 0) then
 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       if(sec_flag(2) .ne. 0) then 
         int_ary(q)=zlevel(k)%cm_zlev(i,j)%ndmeth
       elseif(cmdiff_global .ne. 0) then
             int_ary(q)=cmdiff_global
           else
             int_ary(q)=1
           endif
         enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmdiff='
 appvar=''
 call fidowriting(cur_fileunit,0)
 else
  if(num_cm .eq. 1) then
   write(cur_fileunit, "('cmdiff=',I0)")  cmdiff_global
  else
   write(cur_fileunit, "('cmdiff=',I0,'R',I0)") num_cm, cmdiff_global
  endif
 endif
 
 q=0
 do k=1, num_cmesh(3)
   do j=1,num_cmesh(2)
     do i=1, num_cmesh(1)
       q=q+1
       int_ary(q)=zlevel(k)%cm_zlev(i,j)%qudra_id
     enddo
   enddo
 enddo

 call FidoIntArray(int_ary,num_cm,0,1)
 prevar='cmquad='
 appvar=''
 call fidowriting(cur_fileunit,0)



write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#2  /Section 2 : Fine mesh mat. number')") 
write(cur_fileunit, "('/acceptable keywords: cmmatn (multi) ')")
write(cur_fileunit, "('/ cmmatn=CM#, mat # for each fine mesh in this CM')")

do k=1, num_cmesh(3)
  do j=1, num_cmesh(2)
    do i=1, num_cmesh(1)
      cm_t=(k-1)*num_cm_zlev+(j-1)*num_cmesh(1)+i
      write(cur_fileunit, "('cmmatn=',I0)") cm_t
      solver_id=zlevel(k)%cm_zlev(i,j)%solver_id
      select case(solver_id)
      case(0)
       call WriteNmattp(i,j,k,cur_fileunit)
      case(1)
        write(cur_fileunit, "( I0,2x )" )  zlevel(k)%cm_zlev(i,j)%mat_matrix(1,1,1)
      end select
      
   enddo
 enddo
enddo

write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#3  /Section 3 : src distribution')") 
write(cur_fileunit, "('/acceptable keywords: srcloc, srcmag, srcspm, srcdis (multi), keffin' )")
write(cur_fileunit, "('/ srcloc: source location (CM number where source located), NumOfEntry=numsrc')")
write(cur_fileunit, "('/ srcmag: source strength (srcmag*srcdis=src density in that fm, #/cm3-sec), NumOfEntry=numsrc')")
write(cur_fileunit, "('/ srcspm: source spectrum (srcmag*srcdis*srcspm=src density for a group), NumOfEntry=numsrc*numgrp')")
write(cur_fileunit, "('/ srcdis: source spatial distribution  srcdis=Src#, FineMeshDist')")
write(cur_fileunit, "('/ keffin: initial Keff guess, NumOfEntry=1, (more entries reserved for future Keff accelaration')")
! write(*,*) num_source
if(s_format .ne. 2) then
 

call FidoIntArray(nscmsh,num_source,10,1)
prevar='srcloc='
appvar=''
call fidowriting(cur_fileunit,0)


call FidoRealArray(smag,num_source,-5,0,1)
prevar='srcmag='
appvar=''
call fidowriting(cur_fileunit,0)

call FidoRealArray(serg,num_group*num_source,-3,num_group,1)
prevar='srcspm='
appvar=''
call fidowriting(cur_fileunit,0)

do i=1, num_source
  call TransCmIndex(nscmsh(i), cm_i, cm_j, cm_k)
  write(cur_fileunit,"('srcdis=', I0)") i
  call WriteSpacpf(cm_i,cm_j,cm_k,cur_fileunit,i,1)
enddo

else

call FidoRealArray(rkdef,1,3,0,1)
prevar='keffin='
appvar=''
call fidowriting(cur_fileunit,0)

endif


write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#4  /Section 4 : xs data')") 
write(cur_fileunit, "('/acceptable keywords: xsname, xstype, numcmt, xstihm,  legord, legoxs,xstchi ')")
write(cur_fileunit, "('/ xsname: cross section file name (charater entry)')")
write(cur_fileunit, "('/ xstype: 0=(2l-1) is not pre-multiplied; 1=(2l-1) pre-multiplied ' )")
write(cur_fileunit, "('/ numcmt: number of comment lines in between material xs block')")
write(cur_fileunit, "('/ xstihm: xs table total length, (SigmaTot@Column 3 always ')")
write(cur_fileunit, "('/   xstihm=3+numgrp:  SigmaSelfScatter@4 , downscattering only')")
write(cur_fileunit, "('/   xstihm=3+(2*numgrp-1):  SigmaSelfScatter@(3+numgrp) , upperscattering')")
write(cur_fileunit, "('/ keffin: initial Keff guess, NumOfEntry=1, (more entries reserved for future Keff accelaration')")


write(cur_fileunit, "('xsname=',A)") trim(prb_xs%fullname)
!write(TEMPF90,'(A)') prb_xs%fullname
write(cur_fileunit, '(A7,I1,2X,A7,I1)') 'legord=', legord , 'legoxs=', legoxs
write(cur_fileunit, '(A7,I1)') 'xstype=',nxtyp

write(cur_fileunit, '(A7,I0)')  'xstihm=',ihm 
 
call FidoRealArray(chig,num_mat*num_group,-4,-num_group,1)
prevar='xstchi='
appvar=''
call fidowriting(cur_fileunit,0)
prevar=''
write(cur_fileunit, '(A7,I0,4X)')  'numcmt=',num_comment

write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#5  /Section 5 : boundary cond. and tol.')") 
write(cur_fileunit, "('/acceptable keywords: tolinn,tolout,maxinn,maxout,xminus,xpluss,yminus,ypluss,zminus,zpluss' )")
write(cur_fileunit, "('/ tolinn: inner iteration (within-group) tolerance, negative value: adjustable for keff loop')")
write(cur_fileunit, "('/ tolout: outer iteration (keff loop) tolerance, negative value: adjustable for keff loop ' )")
write(cur_fileunit, "('/ maxinn: maxium inner iteration number, negative value: adjustable for keff loop')")
write(cur_fileunit, "('/ maxout: maxium outer iteration number, negative value: adjustable for keff loop')")
write(cur_fileunit, "('/ xminus,xpluss,yminus,ypluss,zminus,zpluss : Boundary conditions at -x,+x, -y,+y, -z,+z')")
write(cur_fileunit, "('/   =0: vaccum;  =1 albedos for each group: reflective')")

bc_char(1)='xminus='
bc_char(2)='xpluss='
bc_char(3)='yminus='
bc_char(4)='ypluss='
bc_char(5)='zminus='
bc_char(6)='zpluss='

do i=1, 6
 if (bcs(i) .eq. 1) then
   call FidoRealArray(albedo(i)%albedo_grp,num_group,0,0,1)
   write(prevar,"(A7,I1,'    ')") bc_char(i),bcs(i)
   appvar=''
   call fidowriting(cur_fileunit,3) 
 else
   write(cur_fileunit,"(A7,I1)") bc_char(i),bcs(i) 
 endif
enddo

write(cur_fileunit,"('tolinn=',ES12.5 )" ) tolin(1)
write(cur_fileunit,"('tolout=',ES12.5 )" ) tolout(1)
write(cur_fileunit,"('maxout=',I0 )" ) maxitr(1)
write(cur_fileunit,"('maxinn=',I0 )" ) maxitr(2)

if(IsSpect .eq. 1) then
write(cur_fileunit, "('/*************************************************************************')")
write(cur_fileunit,"('#5  /Section 10 (Optional) : SPECT')") 
write(cur_fileunit, "('/acceptable keywords: numang,iniang,endang, vecaxs, posaxs, radius, sptcir,detsiz ' )")
write(cur_fileunit, "('/ numang: number of projection angles')")
write(cur_fileunit, "('/ iniang, endang: rotation starting and endding angles in degree ' )")
write(cur_fileunit, "('/ vecaxs: rotation axis vector, NumOfEntry=3')")
write(cur_fileunit, "('/ posaxs: position of rotation vector, NumOfEntry=3')")
write(cur_fileunit, "('/ radius: rotation radius')")
write(cur_fileunit, "('/ sptcir: circular splitting for collimators')")
write(cur_fileunit, "('/   =splitting order(num of dir on one circle), number of circles, collimator angle')")
write(cur_fileunit, "('/ detsiz: detector size along x and y, in cm and pixels')")
write(cur_fileunit, "('/   =x-size(cm), y-size(cm), #OfPix along x, #ofPix along y')")

write(cur_fileunit, "('numang=',I0)") num_ang
!write(TEMPF90,'(A)') prb_xs%fullname
write(cur_fileunit, "('iniang=', ES12.5)") ang_start
write(cur_fileunit, "('endang=', ES12.5)") ang_end


write(cur_fileunit, "('vecaxs=',3(ES12.5,2x) )")  vec_axis 
write(cur_fileunit, "('posaxs=',3(ES12.5,2x) )")  pos_axis
write(cur_fileunit, "('radius=', ES12.5)") r_axis 

write(cur_fileunit, "('sptcir=',I0, 2x, I0, 2x, ES12.5 )")  spt_order, spt_circle, spt_angle 
write(cur_fileunit, "('detsiz=',2(ES12.5, 2x), 2(I0, 2x) )")  size_det, pix_det 


endif

close(cur_fileunit)
5400 return
5401 cur_filename=outputfile(5)%fullname
     write(err_message,*) 'Error when openning TITAN input file'
     call TrapOpenError(1)
end subroutine


!read in4.inp
Subroutine ReadIn4
use files
use ErrControl
use paraset1, only : input_dir, sec_flag
use paraset4, only : sn_order,prbname
use paraset3
use paraset5
use funs

integer ierr,i
logical ex
! character*1  secnum
character*3 :: twochar='   ' 
! integer :: sec_flag(0:15)=0

sec_flag=0


!looking for bonphora.inp (first) or in4.inp (second) in the input directory
curfile%name='bonphora'
curfile%ext='inp'
curfile%fullname=''
curfile%dir=input_dir
cur_filename=Getfullname(curfile,1)

inquire(file=cur_filename,exist=ex)

if (.not. ex) then
curfile%name='in4'
cur_filename=Getfullname(curfile,1)
inquire(file=cur_filename,exist=ex)
endif

if(.not. ex ) then

num_quad=1
allocate(quad(num_quad))
!default quadrature type =0 , level symetric
quad(1)%tquad=0    
quad(1)%oquad=sn_order
return
endif

!reading transport input deck
write(warning_message,"(' Reading transport input file: ',A)") trim(cur_filename)
call DisplayMsg

open(unit=44,file=cur_filename)

ierr=0
i=0
do while(ierr .eq. 0) 
! secnum='0'
! do while(ierr .eq. 0 .and. secnum .eq. '0')
 i=i+1
 read(44, "(A)", iostat=ierr )  twochar
 if(twochar(1:1) .eq. '#' .and. ierr .eq. 0) then

! enddo
 if( index('0123456789',twochar(3:3)) .eq. 0) twochar(3:3)=' '

 select case (twochar(2:3))
 case ('0 ')
 call ReadIn4_sec0
  sec_flag(0)=1
 case ('1 ') 
  call ReadIn4_sec1
  sec_flag(1)=1
 case ('2 ')
  call ReadIn4_sec2
  sec_flag(2)=1
 case ('3 ')
  call ReadIn4_sec3
  sec_flag(3)=1
 case ('10')  ! Spect Section
  if(IsSpect .ne. 1) then
  write(warning_message,"('bonphora.inp: #10 effective only IsSpect=1  ')") 
  call DisplayMsg 
  stop
  else
  call ReadIn4_sec10
  sec_flag(10)=sec_flag(10)+1
  endif
 case default

  write(warning_message,"('section number is not supported on line:  ',I0,2x,A)") &
        i,trim(cur_filename)
  call DisplayMsg 
 end select
 endif
enddo
close(44)

if(sec_flag(0) .ne. 1) then
write(err_message,"('section 0 is not present in in4.inp or bonphoar.inp ')")  
call TrapInputError(1)
endif
!set default transport parameters if not specified in bonphora.inp
!tolerance and iter. limitation
!if(sec_flag(3) .eq. 0) then
! tolin(1)=1.0e-3
! tolout(1)=1.0e-5
! maxitr(1)=50
! maxitr(2)=10
 
!endif

end subroutine


subroutine  ReadIn4_sec0

use paraset3
use paraset5
use files
use lineread
use ErrControl
use funs

write(READLOG,*)
write(READLOG,"(' Section 0 : General setup ' )" ) 
num_quad=1
cur_var='total number of quadrature'
flag(1)=-1
 if(NumCmtLine(44,flag) .ge. 0) then
  select case(flag(1) )
   case(1)
    read(44,*,err=1002,end=1002) num_quad
   case(2)
    read(44,*,err=1002,end=1002) num_quad, cmdiff_global
   case (3)
    read(44,*,err=1002,end=1002) num_quad, cmdiff_global, IsSpect
   case default
    read(44,*,err=1002,end=1002) num_quad
  end select
 endif
write(READLOG,"(' num_quad ',' : ', I3 )" )  num_quad
if(num_quad .lt. 1) then
write(err_message,"('number of quadrature less than zero')")  
call TrapInputError(1)
endif
allocate(quad(num_quad))

if (flag(1) .eq. 2) then
 write(READLOG,"(' global differencing scheme ',' : ', I3 )" )  cmdiff_global
else if (flag(1) .eq. 3) then
 write(READLOG,"(' IsSpect Simulation Flag',' : ', I3 )" )  IsSpect
else
 write(READLOG,"(' using default global differencing scheme ',' : ', I3 )" )  1
endif

return
1002  call TrapReadError(1)
end subroutine

!read in4.inp section 1
!quadrature section
subroutine  ReadIn4_sec1
  use files
  use paraset5
  use lineread
  use ErrControl
  use funs

  integer i,q

  write(READLOG,*)
  write(READLOG,"(' Section 1 : Quadrature setup ' )" ) 
       
  do q=1, num_quad
    flag=0

    write(READLOG,"(' Qudrature set : ',I3,1x )" ) q

    cur_var='Quad_id sn_order num_split'
    if(NumCmtLine(44,flag) .ge. 0) &
      read(44,*,err=1002,end=1002) quad(q)%tquad, quad(q)%oquad, quad(q)%num_split
    
    write(READLOG,"(' Quad_id, sn_order, num_split ',' : ', I3,I3,I3 )" ) &
         quad(q)%tquad, quad(q)%oquad, quad(q)%num_split
    if(quad(q)%num_split .gt. 0) then
      allocate(quad(q)%direc_split(quad(q)%num_split))
      cur_var='splitted directions id'
      flag(1)=-1
      if(NumCmtLine(44,flag) .ge. 0) then 
        if(flag(1) .lt. quad(q)%num_split) then
          write(err_message,"(' only ',I0,' values found, ',I0,' expected for splitted dir ids ')") &
          flag(1),quad(q)%num_split
          call TrapInputError(1)
        endif
        read(44,*,err=1002,end=1002) (quad(q)%direc_split(i)%spid,i=1,quad(q)%num_split)
      endif
     
      write(form,"('(A24,A3,',I0,'(I3,1X))' )" ) quad(q)%num_split 
      write(READLOG,form) ' splitted directions id ',  ' : ', &
          (quad(q)%direc_split(i)%spid,i=1,quad(q)%num_split)

      cur_var='splitted directions order'
      flag(1)=-1
      if(NumCmtLine(44,flag) .ge. 0) then 
        if(flag(1) .lt. quad(q)%num_split) then
          write(err_message,"(' only ',I0,' values found, ',I0,' expected for splitted dir order ')") &
          flag(1),quad(q)%num_split
          call TrapInputError(1)
        endif
        read(44,*,err=1002,end=1002) (quad(q)%direc_split(i)%order,i=1,quad(q)%num_split)
      endif
      flag(1)=0
      write(form,"('(A28,A3,',I0,'(I3,1X))' )" ) quad(q)%num_split 
      write(READLOG, form ) ' splitted directions order ',  ' : ', &
         (quad(q)%direc_split(i)%order,i=1,quad(q)%num_split)

      cur_var='splitted directions spt_id'
      flag(1)=-1
      if(NumCmtLine(44,flag) .ge. 0) then
        if(flag(1) .ne. 0) then 
          if(flag(1) .lt. quad(q)%num_split) then
            write(err_message,"(' only ',I0,' values found, ',I0,' expected for splitted dir order ')") & 
              flag(1),quad(q)%num_split
            call TrapInputError(1)
          endif
          read(44,*,err=1002,end=1002) (quad(q)%direc_split(i)%spt_id,i=1,quad(q)%num_split)
          read(44,*,err=1002,end=1002) (quad(q)%direc_split(i)%topnum,i=1,quad(q)%num_split)
          if(NumCmtLine(44,flag) .eq. 0) &
            read(44,*,err=1002,end=1002) (quad(q)%direc_split(i)%alpha,i=1,quad(q)%num_split)
          flag(1)=0
          write(form,"('(A28,A3,',I0,'(I3,1X))' )" ) quad(q)%num_split 
          write(READLOG,form ) ' splitted directions spt_id ',' : ', &
            (quad(q)%direc_split(i)%spt_id,i=1,quad(q)%num_split)
          write(form,"('(A28,A3,',I0,'(I3,1X))' )" ) quad(q)%num_split 
          write(READLOG,form ) ' splitted directions topnum ',' : ', &
            (quad(q)%direc_split(i)%topnum,i=1,quad(q)%num_split)
          write(form,"('(A28,A3,',I0,'(ES12.5,2X))' )" ) quad(q)%num_split 
          write(READLOG,form ) ' splitted directions alpha  ',' : ', &
           (quad(q)%direc_split(i)%alpha, i=1,quad(q)%num_split)
        endif 
      endif  
    endif 
  enddo !q 

  return

  1002  call TrapReadError(1)
end subroutine

!solver_id, quad. id and differencing scheme id
subroutine  ReadIn4_sec2
use files

use lineread
use ErrControl
use funs
use paraset4 
use paraset5 

integer i,j,k

write(READLOG,*)
write(READLOG,"(' Section 2 : Solver_id setup for each CM ' )" ) 


flag=0

 cur_var='solver_id '
 do k=1, num_zlev
 write(READLOG,"(' solver_id for z level : ', I3 )" ) k
     
 do j=1, zlevel(1)%ncy
 if(NumCmtLine(44,flag) .ge. 0) then
  read(44,*,err=1002,end=1002) (zlevel(k)%cm_zlev(i,j)%solver_id, i=1, zlevel(1)%ncx )
 endif
 write(form, "('(',I0,'(I0,1x))' )") zlevel(1)%ncx
 write(READLOG,form ) &
     (zlevel(k)%cm_zlev(i,j)%solver_id, i=1, zlevel(1)%ncx )
 enddo
 enddo

if(num_quad .gt. 1) then
 cur_var='qudra_id '
 do k=1, num_zlev
 write(READLOG,"(' solver_id for z level : ', I3 )" ) k
     
 do j=1, zlevel(1)%ncy
 if(NumCmtLine(44,flag) .ge. 0) then
  read(44,*,err=1002,end=1002) (zlevel(k)%cm_zlev(i,j)%qudra_id, i=1, zlevel(1)%ncx )
 endif
 write(form, "('(',I0,'(I0,1x))' )") zlevel(1)%ncx
 write(READLOG,form ) &
     (zlevel(k)%cm_zlev(i,j)%qudra_id, i=1, zlevel(1)%ncx )
 enddo
 enddo

endif

if(cmdiff_global .eq. 0) then
 cur_var='ndmeth '
 do k=1, num_zlev
 write(READLOG,"(' diff. scheme for z level : ', I3 )" ) k
     
 do j=1, zlevel(1)%ncy
 if(NumCmtLine(44,flag) .ge. 0) then
  read(44,*,err=1002,end=1002) (zlevel(k)%cm_zlev(i,j)%ndmeth, i=1, zlevel(1)%ncx )
 endif
 write(form, "('(',I0,'(I0,1x))' )") zlevel(1)%ncx
 write(READLOG,form ) &
     (zlevel(k)%cm_zlev(i,j)%ndmeth, i=1, zlevel(1)%ncx )
 enddo
 enddo

endif

return

1002  call TrapReadError(1)
end subroutine

!read in4.inp section 3
! tolerances , k-guess, max iteration number
subroutine  ReadIn4_sec3
use files
use paraset4 ,only : s_format
use paraset3
use lineread
use ErrControl
use funs


write(READLOG,*)
write(READLOG,"(' Section 3 : Control parameters ' )" ) 
     
flag=0
write(READLOG,"(' outer/inner loop tolerance : ' )" ) 

cur_var='tolerances'
if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) tolout(1), tolin(1)
endif
write(READLOG,"(' outer loop tolerance        : ', ES12.5 )" ) tolout(1)
write(READLOG,"(' within-group loop tolerance : ', ES12.5 )" ) tolin(1)

write(READLOG,"(' outer/inner loop limit : ' )" ) 

cur_var='maxium iteration'
if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) maxitr
endif
write(READLOG,"(' outer loop limit        : ',I0  )" ) maxitr(1)
write(READLOG,"(' within-group loop limit : ',I0 )" ) maxitr(2)

if(s_format .eq. 2) then

cur_var='initial keff'
if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) rkdef
endif
write(READLOG,"(' initial guess of keff   : ', ES12.5 )" ) rkdef

endif
return

1002  call TrapReadError(1)
end subroutine

!read SPECT parameters
subroutine ReadIn4_sec10
use files
use paraset1 
use paraset3
use paraset5
use lineread
use ErrControl
use funs


IsSpect=1
write(READLOG,*)
write(READLOG,"(' Section 10 : SPECT Simulation Parameters ' )" ) 
!     
flag=0
write(READLOG,"(' starting angle, ending angle, and number of projections : ' )" ) 

cur_var='ang_start, ang_end, num_ang'
if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) ang_start, ang_end, num_ang
endif
write(READLOG,"(' starting angle        : ', ES12.5 )" ) ang_start
write(READLOG,"(' ending angle : ', ES12.5 )" ) ang_end
write(READLOG,"(' number of projections : ', I0 )" ) num_ang

write(READLOG,"(' rotation parameters : ' )" ) 

cur_var='rotation axis vector, postion, and rotation radius'
if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) vec_axis
endif

if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) pos_axis
endif

if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) r_axis
endif

write(READLOG,"(' rotation axis vector     : ', 3(ES12.5,2x)  )" ) vec_axis
write(READLOG,"(' rotation axis postion    : ', 3(ES12.5,2x)  )" ) pos_axis
write(READLOG,"(' rotation radius    : ', ES12.5  )" ) r_axis

cur_var='splitting order, number of circles, collimator angle'

if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) spt_order, spt_circle, spt_angle
endif

write(READLOG,"(' splitting order        : ', I0 )" ) spt_order
write(READLOG,"(' number of split circles : ', I0 )" ) spt_circle
write(READLOG,"(' splitting angle (collimator) : ', ES12.5 )" ) spt_angle

cur_var='detector info: size, pixels'

if(NumCmtLine(44,flag) .ge. 0) then
 read(44,*,err=1002,end=1002) size_det, pix_det
endif

write(READLOG,"(' detector size along x        : ', ES12.5 )" ) size_det(1)
write(READLOG,"(' detector size along y        : ', ES12.5 )" ) size_det(2)
write(READLOG,"(' number of pixel along x : ', I0 )" ) pix_det(1)
write(READLOG,"(' number of pixel along x : ', I0 )" ) pix_det(2)
return
1002  call TrapReadError(1)
end subroutine
